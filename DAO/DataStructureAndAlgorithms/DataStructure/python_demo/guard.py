#### 哨兵技巧
# 哨兵可以理解为它可以减少特殊情况的判断，比如判空，比如判越界，比如减少链表插入删除中对空链表的判断，比如例子中对i越界的判断。
# 空与越界可以认为是小概率情况，所以代码每一次操作都走一遍判断，在大部分情况下都会是多余的。
# 哨兵的巧妙就是提前将这种情况去除，比如给一个哨兵结点，以及将key赋值给数组末元素，让数组遍历不用判断越界也可以因为相等停下来。
# 使用哨兵的指导思想应该是将小概率需要的判断先提前扼杀，比如提前给他一个值让他不为null，或者提前预设值，或者多态的时候提前给个空实现，然后在每一次操作中不必再判断以增加效率。


# 在数组a中，查找key，返回key所在的位置
# 其中，n表示数组a的长度
def find(a, n, key):
    # 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
    if a == None or n <= 0:
        return -1

    i = 0
    # 这里有两个比较操作：i<n和a[i]==key.
    while i < n:
        if a[i] == key:
            return i

        i+=1

    return -1



# 在数组a中，查找key，返回key所在的位置
# 其中，n表示数组a的长度
# 我举2个例子，你可以拿例子走一下代码
# a = [4, 2, 3, 5, 9, 6]  n=6 key = 7
# a = [4, 2, 3, 5, 9, 6]  n=6 key = 6
def findWithGuard(a, n, key):
    if a == None or n <= 0:
        return -1

    # 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
    if a[n-1] == key:
        return n-1

    # 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
    # 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
    tmp = a[n-1]
    # 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
    a[n-1] = key

    i = 0
    # while 循环比起代码一，少了i<n这个比较操作
    while a[i] != key:
        i += 1

    # 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
    a[n-1] = tmp

    if i == n-1:
    # 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
        return -1
    else:
    # 否则，返回i，就是等于key值的元素的下标
        return i

print(find([4, 2, 3, 5, 9, 6], 6, 6))
print(findWithGuard([4, 2, 3, 5, 9, 6], 6, 6))