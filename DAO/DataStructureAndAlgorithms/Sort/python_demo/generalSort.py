# 如何实现一个通用的、高性能的排序函数？
'''
几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，Java 语言中的 Collections.sort()。
在平时的开发中，我们也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。
那你知道这些排序函数是如何实现的吗？底层都利用了哪种排序算法呢？

选择排序算法，无非考虑一下几点：
- 排序算法的执行效率: 时间复杂度
- 排序算法的内存消耗: 是否为原地；原地排序算法，就是特指空间复杂度是 O(1) 的排序算法
- 排序算法的稳定性: 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就是稳定的排序

为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函

快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢
归并排序并不是原地排序算法，空间复杂度是 O(n)，空间耗费很大，所以使用归并排序的情况其实并不多

快速排序在最坏情况下的时间复杂度是 O(n2)，如何来解决这个“复杂度恶化”的问题呢？
- O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理
- 最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多，尽可能地让每次分区都比较平均
- 这里介绍两个比较常用、比较简单的分区算法：
    - 三数取中法：
        我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。
        这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。
        但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”
    - 随机法：
        随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。
        这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，
        也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。
        时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。


快速排序是用递归来实现的。我们在递归那一节讲过，递归要警惕堆栈溢出。
为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：
第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。
第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。
(感觉都不好用，js的话还有尾递归、尾递归优化，另开专题研究吧)
'''

