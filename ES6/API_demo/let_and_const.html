<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>let_and_const</title>
</head>

<body>
    <p style="font-size: 90px;margin: 70% 0 0;font-weight: bold;text-align: center;">let_and_const</p>
</body>
<script type="text/javascript">

// let

//////////////////////////////////////////
// for循环的计数器,就很合适使用let命令. //
//////////////////////////////////////////

// 下面的代码如果使用var,最后输出的是10.
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    };
}
a[6](); // 10
// 上面代码中,变量i是var命令声明的,在全局范围内都有效,所以全局只有一个变量i. 
// 每一次循环,变量i的值都会发生改变,而循环内被赋给数组a的函数内部的console.log(i),里面的i指向的就是全局的i. 
// 也就是说,所有数组a的成员里面的i,指向的都是同一个i,导致运行时输出的是最后一轮的i的值,也就是10.

// 如果使用let,声明的变量仅在块级作用域内有效,最后输出的是6.
var b = [];
for (let j = 0; j < 10; j++) {
    b[j] = function() {
        console.log(j);
    };
}
b[6](); // 6
// 上面代码中,变量i是let声明的,当前的i只在本轮循环有效,所以每一次循环的i其实都是一个新的变量,所以最后输出的是6.
//  你可能会问,如果每一轮循环的变量i都是重新声明的,那它怎么知道上一轮循环的值,从而计算出本轮循环的值？ 
//  这是因为 JavaScript 引擎内部会记住上一轮循环的值,初始化本轮的变量i时,就在上一轮循环的基础上进行计算.


// 另外,for循环还有一个特别之处,就是设置循环变量的那部分是一个父作用域,而循环体内部是一个单独的子作用域.
for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
}
// abc
// abc
// abc
// 上面代码正确运行,输出了3次abc.这表明函数内部的变量i与循环变量i不在同一个作用域,有各自单独的作用域.  


////////////////
// 暂时性死区 //
////////////////

// 如果区块中存在let和const命令,这个区块对这些命令声明的变量,从一开始就形成了封闭作用域.凡是在声明之前就使用这些变量,就会报错.

// 有些"死区"比较隐蔽,不太容易发现.
// function bar(x = y, y = 2) {
//   return [x, y];
// }
// bar(); // 报错
// 上面代码中,调用bar函数之所以报错(某些实现可能不报错),是因为参数x默认值等于另一个参数y,而此时y还没有声明,属于"死区".
// 如果y的默认值是x,就不会报错,因为此时x已经声明了.

// 另外,下面的代码也会报错,与var的行为不同.
// 不报错
// var x = x;
// 报错
// let x = x;
// ReferenceError: x is not defined
// 上面代码报错,也是因为暂时性死区.使用let声明变量时,只要变量在还没有声明完成前使用,就会报错.
// 上面这行就属于这个情况,在变量x的声明语句还没有执行完成前,就去取x的值,导致报错"x 未定义".


///////////////////
// 块级作用域 //
///////////////////

// ES5 只有全局作用域和函数作用域,没有块级作用域,这带来很多不合理的场景.
// 第一种场景,内层变量可能会覆盖外层变量.
var tmp = new Date();

function f() {
    console.log(tmp);
    if (false) {
        var tmp = 'hello world';
    }
}
f(); // undefined
// 上面代码的原意是,if代码块的外部使用外层的tmp变量,内部使用内层的tmp变量.
// 但是,函数f执行后,输出结果为undefined,原因在于变量提升,导致内层的tmp变量覆盖了外层的tmp变量.


// 第二种场景,用来计数的循环变量泄露为全局变量.
var s = 'hello';
for (var i = 0; i < s.length; i++) {
    console.log(s[i]);
}
console.log(i); // 5
// 上面代码中,变量i只用来控制循环,但是循环结束后,它并没有消失,泄露成了全局变量.


//////////////////////////////
// do 表达式 (目前只是提案)//
//////////////////////////////

// 本质上,块级作用域是一个语句,将多个操作封装在一起,没有返回值.
// {
//   let t = f();
//   t = t * t + 1;
// };
// 上面代码中,块级作用域将两个语句封装在一起.但是,在块级作用域以外,没有办法得到t的值,因为块级作用域不返回值,除非t是全局变量.
// 现在有一个提案,使得块级作用域可以变为表达式,也就是说可以返回值,办法就是在块级作用域之前加上do,使它变为do表达式.
// let x = do {
//   let t = f();
//   t * t + 1;
// };

// 上面代码中,变量x会得到整个块级作用域的返回值.

// ============================================================================================

// const

//////////////
// 基本用法 //
//////////////

// 1、const声明一个只读的常量.一旦声明,常量的值就不能改变.
// 2、const声明的变量不得改变值,这意味着,const一旦声明变量,就必须立即初始化,不能留到以后赋值.
// 3、const的作用域与let命令相同：只在声明所在的块级作用域内有效.
// 4、const命令声明的常量也是不提升,同样存在暂时性死区,只能在声明的位置后面使用.
// 5、const声明的常量,也与let一样不可重复声明.

//////////////
//   本质   //
//////////////

// const实际上保证的,并不是变量的值不得改动,而是变量指向的那个内存地址不得改动.
// 对于简单类型的数据(数值、字符串、布尔值),值就保存在变量指向的那个内存地址,因此等同于常量.
// 对于复合类型的数据(主要是对象和数组),变量指向的内存地址,保存的只是一个指针,const只能保证这个指针是固定的
// 至于它指向的数据结构是不是可变的,就完全不能控制了.因此,将一个对象声明为常量必须非常小心.

const foo = {};
// 为 foo 添加一个属性,可以成功
foo.prop = 123;
foo.prop // 123
// 将 foo 指向另一个对象,就会报错
// foo = {}; // TypeError: "foo" is read-only   (Uncaught TypeError: Assignment to constant variable.)
// 上面代码中,常量foo储存的是一个地址,这个地址指向一个对象.
// 不可变的只是这个地址,即不能把foo指向另一个地址,但对象本身是可变的,所以依然可以为其添加新属性.


// 下面是另一个例子
const acon = [];
acon.push('Hello'); // 可执行
acon.length = 0;    // 可执行
// acon = ['Dave'];    // 报错
// 上面代码中,常量a是一个数组,这个数组本身是可写的,但是如果将另一个数组赋值给a,就会报错.


// ==================
//   Object.freeze 
// ==================
// 如果真的想将对象冻结,应该使用Object.freeze方法.
const foofreeze = Object.freeze({});
// 常规模式时,下面一行不起作用；
// 严格模式时,该行会报错
// foofreeze.prop = 123;
// 上面代码中,常量foo指向一个冻结的对象,所以添加新属性不起作用,严格模式时还会报错.


//////////////////
// 顶层对象的属性 //
//////////////////

// 顶层对象,在浏览器环境指的是window对象,在Node指的是global对象.ES5之中,顶层对象的属性与全局变量是等价的.
// ES6为了改变这一点,一方面规定,为了保持兼容性,var命令和function命令声明的全局变量,依旧是顶层对象的属性；
// 另一方面规定,let命令、const命令、class命令声明的全局变量,不属于顶层对象的属性.也就是说,从ES6开始,全局变量将逐步与顶层对象的属性脱钩.


/////////////////////
//  global 对象    //
/////////////////////

// ES5 的顶层对象,本身也是一个问题,因为它在各种实现里面是不统一的.
//     浏览器里面,顶层对象是window,但 Node 和 Web Worker 没有window.
//     浏览器和 Web Worker 里面,self也指向顶层对象,但是 Node 没有self.
//     Node 里面,顶层对象是global,但其他环境都不支持.
 
// 同一段代码为了能够在各种环境,都能取到顶层对象,现在一般是使用this变量,但是有局限性.
//     全局环境中,this会返回顶层对象.但是,Node 模块和 ES6 模块中,this返回的是当前模块.
//     函数里面的this,如果函数不是作为对象的方法运行,而是单纯作为函数运行,this会指向顶层对象.但是,严格模式下,这时this会返回undefined.
//     不管是严格模式,还是普通模式,new Function('return this')(),总是会返回全局对象.
//     但是,如果浏览器用了CSP（Content Security Policy,内容安全政策）,那么eval、new Function这些方法都可能无法使用.


// 现在有一个【提案】,在语言标准的层面,引入global作为顶层对象.
// 也就是说,在所有环境下,global都是存在的,都可以从它拿到顶层对象.
// 垫片库system.global模拟了这个提案,可以在所有环境拿到global.

</script>

</html>