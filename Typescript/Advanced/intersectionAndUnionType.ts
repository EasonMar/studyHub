// https://juejin.cn/post/7003142725058969636 --- TS高级类型之字面量类型、联合类型、交叉类型


interface A {
    name: string
    age: number
}

interface B {
    name: number
    id: string
}

/**
 * ================================ 交叉类型 ===============================
 * 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到成为一种类型，合并后的类型将拥有所有成员类型的特性
 * 注意：新的类型 拥有 参与交集 类型的所有属性...
 */
type Intersection = A & B
const cInter: Intersection = {
    age: 4,
    id: '4',
    name // 注意: 当我们交叉的类型中含有相同属性名但属性类型不一样的情况，该属性会成为never类型
}

/**
 * 交叉类型使用场景 
 * 1. 合并接口类型: 将多个接口类型合并成为一个类型是交叉类型的一个常见的使用场景。这样就能相当于实现了接口的继承
 * 2. 合并联合类型: 可以合并多个联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员
 */


/**
 * ================================ 联合类型 ===============================
 * 联合类型表示一个值可以是几种类型之一，用竖线 | 分隔每个类型
 * 1. 基本使用
 * 2. 类型缩减
 * 3. 可辨识联合类型
 * ========================================================================
 * 当我们使用联合类型赋值的时候，数据结构只能选择满足形如A或者形如B
 * 当我们使用联合类型读取属性的时候，只能获取其共同的属性.如果访问的是非共同的属性，必须做好类型保护以防止bug
 */
type Union = A | B;
const cUnion: Union = {
    name: 'cname',
    age: 1
}

const cUnion2: Union = {
    name: 'cname',
    age: 1,
    id: 'id'
}



/**
 * 总结：
 * & - 交叉类型：产生一个包含所有属性的新类型
 * | - 联合类型：产生一个包含所有类型的【选择集】类型
 */



// ================ 2022年9月13日
// | 和 & 并非位运算符。我们可以理解为&表示必须同时满足所有的契约。|表示可以只满足一个契约

interface TA {
    a: string;
    b: string;
}

type TB = {
    b: number;
    c: number[];
}

// ================ TC 的 key 包含 ab 或者 bc 即可，当然，包含 bac 也可以
type TC = TA | TB;

const TCCon1: TC = {
    a: "123",
    b: "456"
}

const TCCon2: TC = {
    b: 123,
    c: [1, 2, 3]
}

const TCCon3: TC = {
    a: '123',
    b: 123,
    c: [1, 2, 3]
}


const TCCon4: TC = {
    a: '123',
    b: '123',
    c: [1, 2, 3]
}


// ================ TD 的 key 必须包含 abc
type TD = TA & TB;

const TDCon: TD = {
    a: '123',
    b: 'never' // b变成了 never 类型
}